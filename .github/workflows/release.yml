name: Release and Publish

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
        default: 'patch'
      prerelease_type:
        description: 'Pre-release type (only for prerelease)'
        required: false
        type: choice
        options:
          - alpha
          - beta
          - rc
        default: 'alpha'
      dry_run:
        description: 'Dry run (only show what would be released)'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_tag: ${{ steps.set_tag.outputs.tag_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare release tag (manual)
        id: set_tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT=${LATEST_TAG#v}
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          PRERELEASE_TYPE="${{ github.event.inputs.prerelease_type }}"

          IFS='.' read -r major minor patch <<< "$CURRENT"
          patch=$(echo "$patch" | sed 's/-.*$//')

          case "$VERSION_TYPE" in
            patch)
              patch=$((patch + 1))
              NEW_VERSION="$major.$minor.$patch"
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              NEW_VERSION="$major.$minor.$patch"
              ;;
            major)
              major=$((major + 1))
              minor=0
              patch=0
              NEW_VERSION="$major.$minor.$patch"
              ;;
            prerelease)
              if [[ "$CURRENT" == *"-"* ]]; then
                BASE_VERSION=$(echo "$CURRENT" | cut -d'-' -f1)
                CURRENT_PRERELEASE=$(echo "$CURRENT" | cut -d'-' -f2)
                PRERELEASE_NUM=$(echo "$CURRENT_PRERELEASE" | grep -o '[0-9]*$' || echo "1")
                PRERELEASE_NUM=$((PRERELEASE_NUM + 1))
                NEW_VERSION="$BASE_VERSION-$PRERELEASE_TYPE.$PRERELEASE_NUM"
              else
                NEW_VERSION="$CURRENT-$PRERELEASE_TYPE.1"
              fi
              ;;
          esac

          NEW_TAG="v$NEW_VERSION"
          echo "tag_name=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Calculated tag $NEW_TAG"

      - name: Create and push tag (manual)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run != 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create annotated tag and push
          git tag -a "${{ steps.set_tag.outputs.tag_name }}" -m "Release ${{ steps.set_tag.outputs.tag_name }}"
          git push origin "${{ steps.set_tag.outputs.tag_name }}"

      - name: Validate tag format
        run: |
          # Determine tag name
          if [[ "${{ github.event_name }}" == 'workflow_dispatch' ]]; then
            TAGNAME="${{ steps.set_tag.outputs.tag_name }}"
          else
            TAGNAME="${{ github.ref_name }}"
          fi

          if [[ ! "$TAGNAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[0-9]+)?)?$ ]]; then
            echo "Error: Tag $TAGNAME does not match semantic versioning format (v1.2.3 or v1.2.3-alpha.1)"
            exit 1
          fi
          echo "Tag $TAGNAME is valid"

      # (previous explicit validation handled above for both manual and release triggers)

  build-and-test:
    name: Build and Test for Release
    runs-on: ubuntu-latest
    needs: validate-release
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for versioning

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --all-extras --dev

      - name: Run linting
        run: |
          uv run ruff check .
          uv run black --check .

      - name: Run type checking
        run: uv run pyright

      - name: Run tests
        run: uv run pytest -v

      - name: Build package
        run: uv build

      - name: Verify version matches tag
        run: |
          # Extract version from built wheel
          WHEEL_VERSION=$(uv run python -c "
          import os
          import glob
          from importlib.metadata import version
          from pathlib import Path

          # Find wheel file
          wheels = glob.glob('dist/*.whl')
          if not wheels:
              raise RuntimeError('No wheel found')

          wheel_path = Path(wheels[0])
          wheel_name = wheel_path.stem

          # Extract version from wheel filename
          # Format: package-version-python-abi-platform
          parts = wheel_name.split('-')
          version_part = parts[1]
          print(version_part)
          ")

          # Determine tag name (use manual-calculated tag when workflow_dispatch)
          if [[ "${{ github.event_name }}" == 'workflow_dispatch' ]]; then
            TAG_FULL="${{ needs.validate-release.outputs.release_tag }}"
          else
            TAG_FULL="${{ github.ref_name }}"
          fi

          # Extract version from tag (remove 'v' prefix)
          TAG_VERSION="${TAG_FULL#v}"

          echo "Wheel version: $WHEEL_VERSION"
          echo "Tag version: $TAG_VERSION"

          if [[ "$WHEEL_VERSION" != "$TAG_VERSION" ]]; then
            echo "Error: Version mismatch between wheel ($WHEEL_VERSION) and tag ($TAG_VERSION)"
            exit 1
          fi

          echo "Version verification successful"

      - name: Test package installation
        run: |
          # Create a fresh environment and test installation
          uv venv --python 3.12 test-release-env
          source test-release-env/bin/activate
          pip install dist/*.whl

          # Test basic functionality
          python -c "
          import sys
          sys.path.insert(0, '.')
          from image_gen_mcp.main import app
          print('Package imports successfully')
          print(f'FastMCP app: {app}')
          "

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-distributions
          path: dist/
          retention-days: 30

  publish-to-testpypi:
    name: Publish to TestPyPI
    runs-on: ubuntu-latest
    needs: build-and-test
    # environment mapping removed to avoid schema validation errors; keep permissions below
    permissions:
      id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing
    steps:
      - name: Download distributions
        uses: actions/download-artifact@v4
        with:
          name: release-distributions
          path: dist/

      - name: Publish to TestPyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/

      - name: Verify TestPyPI publication
        run: |
          echo "Waiting for package to be available on TestPyPI..."
          sleep 30

          # Try to install from TestPyPI (this may fail if dependencies aren't available)
          pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ image-gen-mcp || echo "TestPyPI installation test completed (may have failed due to dependencies)"

  publish-to-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [build-and-test, publish-to-testpypi]
    # environment mapping removed to avoid schema validation errors; keep permissions below
    permissions:
      id-token: write  # IMPORTANT: this permission is mandatory for trusted publishing
    steps:
      - name: Download distributions
        uses: actions/download-artifact@v4
        with:
          name: release-distributions
          path: dist/

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1

      - name: Verify PyPI publication
        run: |
          echo "Waiting for package to be available on PyPI..."
          sleep 60

          # Verify installation from PyPI
          pip install image-gen-mcp
          python -c "
          try:
              import image_gen_mcp
              print('✅ Package successfully installed from PyPI and imports correctly')
          except ImportError as e:
              print(f'❌ Import failed: {e}')
              exit(1)
          "

  create-github-release-assets:
    name: Update GitHub Release with Assets
    runs-on: ubuntu-latest
    needs: [publish-to-pypi, validate-release]
    permissions:
      contents: write
    steps:
      - name: Download distributions
        uses: actions/download-artifact@v4
        with:
          name: release-distributions
          path: dist/

      - name: Create GitHub Release (manual)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate-release.outputs.release_tag }}
          name: Release ${{ needs.validate-release.outputs.release_tag }}
          body: |
            Automated release created via manual trigger.
          files: |
            dist/*.whl
            dist/*.tar.gz
          draft: false
          prerelease: ${{ contains(needs.validate-release.outputs.release_tag, '-') }}

      - name: Upload release assets
        uses: softprops/action-gh-release@v2
        with:
          files: |
            dist/*.whl
            dist/*.tar.gz
          generate_release_notes: true
          append_body: |

            ## Installation

            Install from PyPI:
            ```bash
            pip install image-gen-mcp
            ```

            Install with uv:
            ```bash
            uv add image-gen-mcp
            ```

            Use with uvx:
            ```bash
            uvx --from image-gen-mcp image-gen-mcp
            ```

            ## MCP Integration

            Add to your `mcp.json`:
            ```json
            {
              "mcpServers": {
                "image-gen-mcp": {
                  "command": "uvx",
                  "args": ["--from", "image-gen-mcp", "image-gen-mcp"],
                  "env": {
                    "OPENAI_API_KEY": "your-key-here"
                  }
                }
              }
            }
            ```
