name: Release and Publish

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
        default: 'patch'
      prerelease_type:
        description: 'Pre-release type (only for prerelease)'
        required: false
        type: choice
        options:
          - alpha
          - beta
          - rc
        default: 'alpha'
      dry_run:
        description: 'Dry run (only show what would be released)'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  validate-release:
    name: Validate Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_tag: ${{ steps.set_tag.outputs.tag_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Prepare release tag (manual)
        id: set_tag
        if: github.event_name == 'workflow_dispatch'
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT=${LATEST_TAG#v}
          VERSION_TYPE="${{ github.event.inputs.version_type }}"
          PRERELEASE_TYPE="${{ github.event.inputs.prerelease_type }}"

          IFS='.' read -r major minor patch <<< "$CURRENT"
          patch=$(echo "$patch" | sed 's/-.*$//')

          case "$VERSION_TYPE" in
            patch)
              patch=$((patch + 1))
              NEW_VERSION="$major.$minor.$patch"
              ;;
            minor)
              minor=$((minor + 1))
              patch=0
              NEW_VERSION="$major.$minor.$patch"
              ;;
            major)
              major=$((major + 1))
              minor=0
              patch=0
              NEW_VERSION="$major.$minor.$patch"
              ;;
            prerelease)
              if [[ "$CURRENT" == *"-"* ]]; then
                BASE_VERSION=$(echo "$CURRENT" | cut -d'-' -f1)
                CURRENT_PRERELEASE=$(echo "$CURRENT" | cut -d'-' -f2)
                PRERELEASE_NUM=$(echo "$CURRENT_PRERELEASE" | grep -o '[0-9]*$' || echo "1")
                PRERELEASE_NUM=$((PRERELEASE_NUM + 1))
                NEW_VERSION="$BASE_VERSION-$PRERELEASE_TYPE.$PRERELEASE_NUM"
              else
                NEW_VERSION="$CURRENT-$PRERELEASE_TYPE.1"
              fi
              ;;
          esac

          NEW_TAG="v$NEW_VERSION"
          echo "tag_name=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Calculated tag $NEW_TAG"

      - name: Create and push tag (manual)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run != 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create annotated tag and push
          git tag -a "${{ steps.set_tag.outputs.tag_name }}" -m "Release ${{ steps.set_tag.outputs.tag_name }}"
          git push origin "${{ steps.set_tag.outputs.tag_name }}"

      - name: Validate tag format
        run: |
          # Determine tag name
          if [[ "${{ github.event_name }}" == 'workflow_dispatch' ]]; then
            TAGNAME="${{ steps.set_tag.outputs.tag_name }}"
          else
            TAGNAME="${{ github.ref_name }}"
          fi

          if [[ ! "$TAGNAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9]+(\.[0-9]+)?)?$ ]]; then
            echo "Error: Tag $TAGNAME does not match semantic versioning format (v1.2.3 or v1.2.3-alpha.1)"
            exit 1
          fi
          echo "Tag $TAGNAME is valid"

      # (previous explicit validation handled above for both manual and release triggers)

  build-and-test:
    name: Build and Test for Release
    runs-on: ubuntu-latest
    needs: validate-release
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for versioning

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          enable-cache: true

      - name: Set up Python
        run: uv python install 3.12

      - name: Install dependencies
        run: uv sync --all-extras --dev

      - name: Run linting
        run: |
          uv run ruff check .
          uv run black --check .

      - name: Run type checking
        run: uv run pyright

      - name: Run tests
        run: uv run pytest -v

      - name: Build package
        run: uv build

      - name: Verify version matches tag
        run: |
          # Extract version from built wheel
          WHEEL_VERSION=$(uv run python -c "
          import os
          import glob
          from importlib.metadata import version
          from pathlib import Path

          # Find wheel file
          wheels = glob.glob('dist/*.whl')
          if not wheels:
              raise RuntimeError('No wheel found')

          wheel_path = Path(wheels[0])
          wheel_name = wheel_path.stem

          # Extract version from wheel filename
          # Format: package-version-python-abi-platform
          parts = wheel_name.split('-')
          version_part = parts[1]
          print(version_part)
          ")

          # Determine tag name (use manual-calculated tag when workflow_dispatch)
          if [[ "${{ github.event_name }}" == 'workflow_dispatch' ]]; then
            TAG_FULL="${{ needs.validate-release.outputs.release_tag }}"
          else
            TAG_FULL="${{ github.ref_name }}"
          fi

          # Extract version from tag (remove 'v' prefix)
          TAG_VERSION="${TAG_FULL#v}"

          echo "Wheel version: $WHEEL_VERSION"
          echo "Tag version: $TAG_VERSION"

          if [[ "$WHEEL_VERSION" != "$TAG_VERSION" ]]; then
            echo "Error: Version mismatch between wheel ($WHEEL_VERSION) and tag ($TAG_VERSION)"
            exit 1
          fi

          echo "Version verification successful"

      - name: Test package installation
        run: |
          # Create a fresh environment and test installation
          # Use python -m venv --upgrade-deps so pip/setuptools/wheel are present at creation
          python -m venv --upgrade-deps test-release-env
          # Basic diagnostics
          echo "Runner python: $(python -V 2>&1)"
          echo "Using uv to create venv with Python 3.12"

          # Ensure the venv has pip available; some venvs may be created without pip
          if ! ./test-release-env/bin/python -m pip --version >/dev/null 2>&1; then
            echo "pip not found in venv; attempting to bootstrap with ensurepip"
            # Try ensurepip if available
            if ./test-release-env/bin/python -c "import importlib,sys; importlib.import_module('ensurepip'); sys.exit(0)" 2>/dev/null; then
              ./test-release-env/bin/python -m ensurepip --upgrade || true
            else
              echo "ensurepip not available; attempting to bootstrap pip via get-pip.py"
              curl -sS https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py
              ./test-release-env/bin/python /tmp/get-pip.py || true
            fi
          fi

          # Fail early with diagnostics if pip still missing
          if ! ./test-release-env/bin/python -m pip --version >/dev/null 2>&1; then
            echo "ERROR: pip is not available in the virtualenv even after bootstrapping"
            ./test-release-env/bin/python -V || true
            ./test-release-env/bin/python -c "import sys,sysconfig; print('sys.executable =', sys.executable); print(sysconfig.get_paths())"
            exit 1
          fi

          # Upgrade packaging tools and install the built wheel into the venv
          export PIP_NO_INPUT=1
          ./test-release-env/bin/python -m pip install --upgrade pip setuptools wheel

          # Retry loop for pip install to mitigate transient network issues
          ATTEMPTS=0
          MAX_ATTEMPTS=3
          SUCCESS=0
          # Prefer wheel, but fall back to sdist if necessary
          WHEEL_FILE=$(ls dist/*.whl 2>/dev/null | head -n1 || true)
          if [ -n "$WHEEL_FILE" ]; then
            PKG_FILE="$WHEEL_FILE"
          else
            SDIST_FILE=$(ls dist/*.tar.gz 2>/dev/null | head -n1 || true)
            if [ -n "$SDIST_FILE" ]; then
              echo "No wheel found, will install sdist: $SDIST_FILE"
              PKG_FILE="$SDIST_FILE"
            else
              echo "ERROR: no wheel or sdist found in dist/"
              ls -la dist || true
              exit 1
            fi
          fi

          while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
            ATTEMPTS=$((ATTEMPTS+1))
            echo "pip install attempt $ATTEMPTS"
            ./test-release-env/bin/python -m pip install --no-cache-dir "$PKG_FILE" && { SUCCESS=1; break; }
            echo "pip install failed, sleeping before retry"
            sleep $((ATTEMPTS * 5))
          done

          if [ $SUCCESS -ne 1 ]; then
            echo "ERROR: pip install failed after $MAX_ATTEMPTS attempts"
            ./test-release-env/bin/python -m pip --version || true
            ./test-release-env/bin/python -m pip list || true
            exit 1
          fi

          # Diagnostics: venv python and installed packages
          ./test-release-env/bin/python -V || true
          ./test-release-env/bin/python -m pip --version || true
          ./test-release-env/bin/python -m pip list || true

          # Test basic functionality using the venv's python (imports from installed wheel)
          # Create a small python script to validate the installed package (non-invasive)
          printf '%s\n' "import importlib" \
            "pkg = importlib.import_module('image_gen_mcp')" \
            "print('Package imports successfully:', pkg.__name__)" \
            "print('version:', getattr(pkg, '__version__', 'unknown'))" > /tmp/test_installed.py
          REPO_DIR=$(pwd)
          # Run the test script from /tmp so the local repo package directory is not picked up
          cd /tmp && "$REPO_DIR/test-release-env/bin/python" /tmp/test_installed.py || (echo 'ERROR: installed package import failed' && exit 1)
          # cleanup
          rm -f /tmp/test_installed.py || true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-distributions
          path: dist/
          retention-days: 30

  publish-to-testpypi:
    name: Publish to TestPyPI
    runs-on: ubuntu-latest
    needs: build-and-test
    # This job requires a TestPyPI API token in the repo secret `TEST_PYPI_API_TOKEN`.
    permissions:
      contents: read
    steps:
      - name: Download distributions
        uses: actions/download-artifact@v4
        with:
          name: release-distributions
          path: dist/
      - name: Ensure TestPyPI token exists
        run: |
          if [ -z "${{ secrets.TEST_PYPI_API_TOKEN }}" ]; then
            echo "Error: secret TEST_PYPI_API_TOKEN is not set. Set the secret and re-run the workflow."
            exit 1
          fi

      - name: Publish to TestPyPI (token)
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          user: __token__
          password: ${{ secrets.TEST_PYPI_API_TOKEN }}

      - name: Verify TestPyPI publication
        run: |
          echo "Waiting for package to be available on TestPyPI..."
          sleep 30

          # Try to install from TestPyPI (this may fail if dependencies aren't available)
          pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ image-gen-mcp || echo "TestPyPI installation test completed (may have failed due to dependencies)"

  publish-to-pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: [build-and-test, publish-to-testpypi]
    # This job requires a PyPI API token in the repo secret `PYPI_API_TOKEN`.
    permissions:
      contents: read
    steps:
      - name: Download distributions
        uses: actions/download-artifact@v4
        with:
          name: release-distributions
          path: dist/
      - name: Ensure PyPI token exists
        run: |
          if [ -z "${{ secrets.PYPI_API_TOKEN }}" ]; then
            echo "Error: secret PYPI_API_TOKEN is not set. Set the secret and re-run the workflow."
            exit 1
          fi

      - name: Publish to PyPI (token)
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}

      - name: Verify PyPI publication
        run: |
          echo "Waiting for package to be available on PyPI..."
          sleep 60

          # Verify installation from PyPI
          pip install image-gen-mcp
          python -c "
          try:
              import image_gen_mcp
              print('✅ Package successfully installed from PyPI and imports correctly')
          except ImportError as e:
              print(f'❌ Import failed: {e}')
              exit(1)
          "

  create-github-release-assets:
    name: Update GitHub Release with Assets
    runs-on: ubuntu-latest
    needs: [publish-to-pypi, validate-release]
    permissions:
      contents: write
    steps:
      - name: Download distributions
        uses: actions/download-artifact@v4
        with:
          name: release-distributions
          path: dist/

      - name: Create GitHub Release (manual)
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run != 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.validate-release.outputs.release_tag }}
          name: Release ${{ needs.validate-release.outputs.release_tag }}
          body: |
            Automated release created via manual trigger.
          files: |
            dist/*.whl
            dist/*.tar.gz
          draft: false
          prerelease: ${{ contains(needs.validate-release.outputs.release_tag, '-') }}

      - name: Upload release assets
        uses: softprops/action-gh-release@v2
        with:
          # Ensure a tag is provided (required by GitHub Releases). Prefer the validated tag
          # when this workflow was manually dispatched; otherwise fall back to the ref name.
          tag_name: ${{ github.event_name == 'workflow_dispatch' && needs.validate-release.outputs.release_tag || github.ref_name }}
          files: |
            dist/*.whl
            dist/*.tar.gz
          generate_release_notes: true
          append_body: |

            ## Installation

            Install from PyPI:
            ```bash
            pip install image-gen-mcp
            ```

            Install with uv:
            ```bash
            uv add image-gen-mcp
            ```

            Use with uvx:
            ```bash
            uvx --from image-gen-mcp image-gen-mcp
            ```

            ## MCP Integration

            Add to your `mcp.json`:
            ```json
            {
              "mcpServers": {
                "image-gen-mcp": {
                  "command": "uvx",
                  "args": ["--from", "image-gen-mcp", "image-gen-mcp"],
                  "env": {
                    "OPENAI_API_KEY": "your-key-here"
                  }
                }
              }
            }
            ```
